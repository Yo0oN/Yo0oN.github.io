---
title: Scale-out에서 데이터 불일치를 해결하는 방법 1편 (Sticky Session, Session Clustering)
modified: 2020-10-24
author: Yo0oN
categories: [Project, festa]
tags: [Project]
math: true
---

<hr>

## 1. 데이터 불일치를 해결하는 방법

대용량 트래픽이 발생할 경우 Scale-out 방식으로 서버를 늘려 프로젝트를 진행하기로 하였다.

하지만 Scale-out의 경우 서버가 여러대이기 때문에 서버 간 데이터가 일치하지 않는 현상을 처리해야 한다.<br>
대표적으로 로그인을 예시로 들어보자면, 로그인 시 Session을 생성하여 서버에 저장하고, 해당 세션을 이용하여 사용자가 로그인 상태임을 알 수 있다.<br>
그런데 서버가 여러개인 경우 로그인했던 서버가 아닌 다른 서버로 다시 요청을 하면 다른 서버에는 Session이 없기 때문에 로그인 상태에서 벗어나버린다.

이 때 사용하는 방법이 ***Sticky Session***과 ***Session Clustering***, ***In-MemoryDB***를 사용하는 방법이 있다.<br>

## 2. Sticky Session

Sticky Session은 처음 요청을 보냈을 때 응답을 준 서버로만 계속 요청을 보내, 특정 서버에 붙어있는 방식이다.

![StickySession](/images/posts/Project/event-recommender-festa/대용량트래픽/StickySession01.jpg)

그림에서 보듯 첫번째 요청은 계속 첫번째 서버로만, 두번째 요청은 두번째 서버로만 전달되며, 가운데에서 분배해주는 일을 하는 것을 **Load Balancer**라고 부른다.<br>
Load Balancer는 요청한 브라우저의 쿠키를 확인하여 해당 쿠키에 해당하는 서버로, 쿠키가 없다면 새로운 쿠키를 생성한 후 서버로 보내준다.

특정 서버로만 요청을 하기 때문에 세션이 그대로 있어 데이터 불일치 문제를 해결할 수 있으나, 단점도 있다.<br>
만약 서버 하나로만 많은 요청이 몰릴 수 있다는 것과, 자신의 세션이 없는 다른 서버는 사용할 수 없다는 것이다.<br>
또, 하나의 서버가 사용할 수 없게 되는 상황이 오면 해당 서버에 있는 세션들을 모두 사용할 수 없다.
<br><br>

## 3. Session Clustering

Session Clustering은 여러 서버가 하나처럼 작동하도록 하는 기술이다.<br>
Sticky Session과는 다르게 여러 서버를 하나로 묶어 사용하기 때문에 서버가 하나 종료된다고 하더라도, 다른 서버들이 있어 문제가 생기지 않는다.

Session Clustering은 사용하는 WAS에 따라 다른 방법이 적용되기 때문에 사용하는 WAS를 살펴봐야한다.<br>
현재 진행중인 프로젝트는 스프링 부트로 진행중이며, 스프링부트는 Tomcat을 내장중이기 때문에 [Tomcat의 Session Clustering](https://tomcat.apache.org/tomcat-9.0-doc/cluster-howto.html) 방법을 찾아보자.
> 사용 중인 스프링 부트는 2.3.4 버전이고, 해당 버전은 Tomcat 9.0.38을 사용한다.(2020-10-23)<br>
> [mvnrepository.com](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-tomcat)에서 확인하거나, 정확하게 알고싶다면 진행중인 프로젝트의 외부 라이브러리 목록을 확인하자.
<br>

### 3-1. all-to-all

Tomcat9의 Session Clustering 문서를 보면 가장 처음 나와있는 방법인데, Delta Manager를 사용하여 특정 노드에서 발생한 Session 정보를 나머지 모든 노드에 복제하는 방식이다.<br>
이렇게 하면 어떤 서버로 요청을 해도 모든 세션을 가지고 있기 때문에 데이터 불일치 문제를 해결할 수 있고, 한 서버에 장애가 생기더라도 다른 서버가 작동 중이기 때문에 장애문제도 해결할 수 있다.

하지만 이 방법은 모든 데이터를 각 노드에 저장해야 하고, 배포용 노드가 아닌 경우에도 복제되기 때문에 메모리 문제가 발생한다.<br>
또, 세션 데이터가 저장될 때마다 모든 서버에 똑같은 값을 저장해주어야 하므로 서버 수가 많아질수록 성능 저하가 발생해 서버가 4개 이상인 경우에는 권장하지 않고 있다.
<br>

### 3-2. Primary-secondary

이 방법은 Backup Manager를 사용하여 특정 노드에서 발생한 세션 정보를 나머지 하나의 노드에만 복제하여, 총 두개의 노드에만 세션을 가지고 있는 방법이다.<br>
순서는 아래와 같다.

1. 요청이 들어오면 로드밸런서에 의해 선택된 서버가 세션을 생성하고, 해당 서버는 **Primary node**가 된다.
2. 그 후 다른 서버 중 하나가 Primary node의 데이터를 복제하여 **Backup node**가 된다.
3. 나머지 서버들은 Primary와 secondory node의 주소와 key만 복제되어서 **Proxy node**가 된다.

여기서 Proxy node는 *세션 key*와 *Primary node, Backup node의 주소*를 저장하고 있어서 Proxy node로 요청이 들어올 경우 Proxy는 가지고 있는 Primary node의 주소를 이용해 Primary node에 해당하는 세션 데이터를 요청하여 데이터 불일치 문제를 해결한다.

데이터 불일치 문제를 해결했으니 장애문제를 살펴보자.<br>
Primary node에 장애가 생길 경우 Backup node가 Primary node로 변하여 또 다른 Backup node를 만들어낸다. (반대의 경우도 마찬가지)<br>
장애 문제도 원할하게 해결되고 있다.

하지만 해당 방식은 Proxy 서버에 요청이 들어오면 다시 Primary 서버에 요청을 하여 Key에 대한 값을 받아와야 한다는 단점이 아직 존재하고, 계속해서 복제가 일어난다는 단점이 있다.<br>

그래서 이런 단점들을 보완한 세션 스토리지(세션 저장소)만 따로 분리하는 방법이 존재하는데, 해당 방법은 다음 글에서 진행됩니다.

<br>

**참고**
- Apache Tomcat9 Doc, https://tomcat.apache.org/tomcat-9.0-doc/cluster-howto.html

**다음 글**
- [Scale-out에서 데이터 불일치를 해결하는 방법 2편]()

**관련 프로젝트**
- [event-recommender-festa](https://github.com/f-lab-edu/event-recommender-festa) (2020-09 ~)

